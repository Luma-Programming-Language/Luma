@module "io"

const SYS_READ: int = 3;
const SYS_WRITE: int = 4;
const SYS_OPEN: int = 5;
const SYS_CLOSE: int = 6;

const O_RDONLY: int = 0;
const O_RDWR: int = 2;

const STDOUT: int = 1;
const STDERR: int = 2;

const local_memcpy -> fn (dest: *void, src: *void, n: int) *void {
    let d: *byte = cast<*byte>(dest);
    let s: *byte = cast<*byte>(src);
    loop [i: int = 0](i < n) : (++i) {
        d[i] = s[i];
    }
    return dest;
}

#returns_ownership 
const local_realloc -> fn (ptr: *void, new_size: int) *void {
    if (ptr == cast<*void>(0)) {
        return alloc(new_size);
    }
    let new_ptr: *void = alloc(new_size);
    local_memcpy(new_ptr, ptr, new_size);
    free(ptr);
    return new_ptr;
}

const local_write -> fn (fd: int, buf: *void, count: int) int {
    return __syscall__(4, fd, cast<int>(buf), count);
}

const local_read -> fn (fd: int, buf: *void, count: int) int {
    return __syscall__(3, fd, cast<int>(buf), count); 
}

const local_open -> fn (path: *byte, flags: int, mode: int) int {
    return __syscall__(5, cast<int>(path), flags, mode);
}

const local_close -> fn (fd: int) int {
    return __syscall__(6, fd);
}

const local_is_error -> fn (result: int) bool {
    return result < 0 && result >= -4095;
}

const local_write_str -> fn (fd: int, s: *byte) int {
    let len: int = 0;
    loop (s[len] != cast<byte>(0)) : (++len) {}
    return local_write(fd, cast<*void>(s), len);
}

const local_eprint -> fn (s: *byte) int {
    return local_write_str(STDERR, s);
}

const INITIAL_BUFFER_SIZE: int = 4096;
const BUFFER_GROWTH_FACTOR: int = 2; 

const ARG_INT: int = 0;
const ARG_STR: int = 1;
const ARG_BYTE: int = 2;
const ARG_FLOAT: int = 3;

pub const FormatArg -> struct {
  tag: int,
  str_ptr: *byte, 
  int_val: int,     
  byte_val: byte
};

pub const NULL_FORMAT_ARG: FormatArg = FormatArg {
  tag: -1,
  str_ptr: cast<*byte>(0),
  int_val: 0,
  byte_val: '\0'
};

pub const str_arg -> fn (arg: *byte) FormatArg {
  return FormatArg { 
    tag: ARG_STR,
    str_ptr: arg,
    int_val: 0,
    byte_val: '\0',
  };
}

pub const int_arg -> fn (arg: int) FormatArg {
  return FormatArg { 
    tag: ARG_INT,
    str_ptr: "",
    int_val: arg,
    byte_val: '\0',
  };
}

pub const byte_arg -> fn (arg: byte) FormatArg {
  return FormatArg { 
    tag: ARG_BYTE,
    str_ptr: "",
    int_val: 0,
    byte_val: arg,
  };
}

#returns_ownership
const from_int -> fn (n: int) *byte {
  if (n == 0) { 
    let s: *byte = cast<*byte>(alloc(2 * sizeof<byte>));
    s[0] = '0';
    s[1] = cast<byte>(0);
    return s;
  }

  let negative: int = 0;
  if (n < 0) {
    negative = 1;
    n = -n;
  }

  let buffer: [byte; 20];
  let i: int = 0;

  loop (n != 0) {
    let digit: int = n % 10;
    buffer[i] = cast<byte>(digit + cast<int>('0'));
    n = n / 10;
    i = i + 1;
  }

  if (negative == 1) {
    buffer[i] = '-';
    i = i + 1;
  }

  let s: *byte = cast<*byte>(alloc((i + 1) * sizeof<byte>));
  loop [j: int = 0](j < i) : (j = j + 1) {
    s[j] = buffer[i - j - 1];
  }
  s[i] = cast<byte>(0);

  return s;
}

pub const print -> fn (s: *byte, args: [FormatArg; 256]) int {
    let buffer: [byte; 1024];
    let buf_index: int = 0;
    let arg_index: int = 0;
    
    let i: int = 0;
    loop (s[i] != '\0') {
      if (s[i] == '%' && arg_index < 256) {
        let next: byte = s[i + 1];
        let arg: FormatArg = args[arg_index];
        
        switch (next) {
          'd' -> {
            if (arg.tag == ARG_INT) {
              let num_str: *byte = from_int(arg.int_val);
              
              loop [j: int = 0](num_str[j] != '\0') : (++j) {
                  buffer[buf_index] = num_str[j];
                  buf_index = buf_index + 1;
              }
              arg_index = arg_index + 1;
              i = i + 2;

              free(num_str);
              continue;
            }
          }
          'c' -> {
            if (arg.tag == ARG_BYTE) {
              buffer[buf_index] = arg.byte_val;
              buf_index = buf_index + 1;
              arg_index = arg_index + 1;
              i = i + 2;
              continue;
            }
          }
          's' -> {
            if (arg.tag == ARG_STR) {
                let str_arg: *byte = arg.str_ptr;
                
                loop [j: int = 0](str_arg[j] != '\0') : (++j) {
                    buffer[buf_index] = str_arg[j];
                    buf_index = buf_index + 1;
                }
                arg_index = arg_index + 1;
                i = i + 2;
                continue;
            }
          }
        }
      }

      buffer[buf_index] = s[i];
      buf_index = buf_index + 1;
      i = i + 1;
    }
      
    let written: int = local_write(STDOUT, cast<*void>(&buffer), buf_index);
    return written;
}

pub const print_err -> fn (s: *byte, args: [int; 256]) int {
  let buffer: *byte = cast<*byte>(alloc(256 * sizeof<byte>));
  let buf_index: int = 0; 
  let arg_index: int = 0;
  defer { free(buffer); }
  
  loop [i: int = 0](s[i] != '\0') : (++i) {
      if (s[i] == '%' && s[i + 1] == 'd' && arg_index < 256) {
          let num_str: *byte = from_int(args[arg_index]);
          defer { free(num_str); }

          loop [j: int = 0](num_str[j] != '\0') : (++j) {
              buffer[buf_index] = num_str[j];
              buf_index = buf_index + 1;
          }
          arg_index = arg_index + 1;
          i = i + 1;
      } else {
          buffer[buf_index] = s[i];
          buf_index = buf_index + 1;
      }
  }
  buffer[buf_index] = '\0';

  let written: int = local_write_str(STDERR, buffer);
  return written;
}

#returns_ownership
pub const read_file -> fn (path: *byte) *byte {
  let fd: int = local_open(path, O_RDONLY, 0);
  if (local_is_error(fd)) {
    local_eprint("Error: File does not exist, can not read from file\n");
    return cast<*byte>(0);
  }

  let buffer_size: int = INITIAL_BUFFER_SIZE;
  let buffer: *byte = cast<*byte>(alloc(buffer_size * sizeof<byte>));
  if (buffer == cast<*byte>(0)) {
    local_eprint("Error: Failed to allocate initial buffer\n");
    local_close(fd);
    return cast<*byte>(0);
  }

  let total_read: int = 0;
  let bytes_read: int = 0;

  loop {
    let read_size: int = buffer_size - total_read - 1;
    bytes_read = local_read(fd, cast<*void>(cast<int>(buffer) + total_read), read_size);

    if (local_is_error(bytes_read)) {
      local_eprint("Error: Failed to read from file\n");
      local_close(fd);
      free(buffer);
      return cast<*byte>(0);
    }

    if (bytes_read == 0) {
      break;
    }

    total_read = total_read + bytes_read;

    if (total_read >= buffer_size - 1) {
      let new_size: int = buffer_size * BUFFER_GROWTH_FACTOR;
      let new_buffer: *byte = cast<*byte>(local_realloc(cast<*void>(buffer), new_size * sizeof<byte>));
      
      if (new_buffer == cast<*byte>(0)) {
        local_eprint("Error: Failed to grow buffer\n");
        local_close(fd);
        free(buffer);
        return cast<*byte>(0);
      }

      buffer = new_buffer;
      buffer_size = new_size;
    }
  }

  buffer[total_read] = cast<byte>(0);

  if (total_read < buffer_size - 1) {
    let final_buffer: *byte = cast<*byte>(alloc((total_read + 1) * sizeof<byte>));
    if (final_buffer != cast<*byte>(0)) {
      local_memcpy(cast<*void>(final_buffer), cast<*void>(buffer), total_read + 1);
      free(buffer);
      buffer = final_buffer;
    }
  }

  local_close(fd);
  return buffer;
}

pub const write_buffer_to_file -> fn (path: *byte, buffer: *byte) int {
    let fd: int = local_open(path, O_RDWR, 0);
    if (local_is_error(fd)) {
       local_eprint("Error: File does not exist, can not write to file.\n");
       return -1;
    }
    
    let length: int = 0;
    loop (buffer[length] != '\0') {
       length = length + 1;
    }

    if (length <= 0) {
       local_eprint("Error: buffer size <= 0.\n");
       local_close(fd);
       return -1;
    }
    
    let written: int = local_write(fd, cast<*void>(buffer), length);
    local_close(fd);
    return written;
}
