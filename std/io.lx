//! Input/Output operations module
//!
//! This module provides formatted printing functions and file reading capabilities.
//! It supports basic format specifiers (%d, %s, %c) for printing different types
//! and includes a dynamic buffer system for efficient file reading.

@module "io"

@use "string" as string
@use "memory" as mem
@use "sys" as sys

/// Initial buffer size for file reading operations (4KB)
const INITIAL_BUFFER_SIZE: int = 4096;
/// Factor by which buffers grow when they need to expand
const BUFFER_GROWTH_FACTOR: int = 2; 

/// Type tags for format arguments
pub const ARG_INT: int = 0;
pub const ARG_STR: int = 1;
pub const ARG_BYTE: int = 2;
pub const ARG_FLOAT: int = 3;

pub const FormatArg -> struct {
  tag: int,
  str_ptr: *byte, 
  int_val: int,     
  byte_val: byte
};

pub const str_arg -> fn (arg: *byte) FormatArg {
  return FormatArg { 
    tag: ARG_STR,
    str_ptr: arg,
    int_val: 0,
    byte_val: '\0',
  };
}

pub const int_arg -> fn (arg: int) FormatArg {
  return FormatArg { 
    tag: ARG_INT,
    str_ptr: "",
    int_val: arg,
    byte_val: '\0',
  };
}

pub const byte_arg -> fn (arg: byte) FormatArg {
  return FormatArg { 
    tag: ARG_BYTE,
    str_ptr: "",
    int_val: 0,
    byte_val: arg,
  };
}

/// Prints a formatted string with mixed-type arguments to stdout
///
/// This function performs printf-style formatting, supporting:
/// * %d - integers
/// * %s - strings
/// * %c - bytes/characters
/// * %f - floats (requires precision, e.g., %.2f)
///
/// The number of arguments consumed is determined by the number of format
/// specifiers in the format string. The args array is bounds-checked to
/// prevent buffer overruns.
///
/// # Parameters
/// * `s` - Format string containing text and format placeholders
/// * `args` - Array of FormatArg structs containing typed arguments
///
/// # Returns
/// The number of bytes written to stdout, or an error code if writing fails
///
/// # Example
/// ```luma
/// let name: *byte = "Alice";
/// let age: int = 30;
/// let initial: byte = 'A';
/// 
/// let name_ptr: *void = cast<*void>(&name);
/// let age_ptr: *void = cast<*void>(&age);
/// let initial_ptr: *void = cast<*void>(&initial);
/// 
/// let args: [FormatArg; 256];
/// args[0] = FormatArg { tag: ARG_STR, data: name_ptr };
/// args[1] = FormatArg { tag: ARG_INT, data: age_ptr };
/// args[2] = FormatArg { tag: ARG_BYTE, data: initial_ptr };
/// 
/// print("Name: %s, Age: %d, Initial: %c\n", args);
/// ```
///
/// # Memory
/// Allocates a 1024-byte temporary buffer which is automatically freed via defer
pub const print -> fn (s: *byte, args: [FormatArg; 256]) int {
    let buffer: *byte = cast<*byte>(alloc(1024 * sizeof<byte>));
    let buf_index: int = 0;
    let arg_index: int = 0;
    defer { free(buffer); }
    
    let i: int = 0;
    loop (s[i] != '\0') {
      if (s[i] == '%' && arg_index < 256) {
        let next: byte = s[i + 1];
        let arg: FormatArg = args[arg_index];
        
        switch (next) {
          'd' -> {
            if (arg.tag == ARG_INT) {
              let num_str: *byte = string::from_int(arg.int_val);
              defer { free(num_str); }
              
              loop [j: int = 0](num_str[j] != '\0') : (++j) {
                  buffer[buf_index] = num_str[j];
                  buf_index = buf_index + 1;
              }
              arg_index = arg_index + 1;
              i = i + 2; // Skip the 'd'
              continue;
            }
          }
          'c' -> {
            if (arg.tag == ARG_BYTE) {
              buffer[buf_index] = arg.byte_val;
              buf_index = buf_index + 1;
              arg_index = arg_index + 1;
              i = i + 2; // Skip the 'c'
              continue;
            }
          }
          's' -> {
            if (arg.tag == ARG_STR) {
                let str_arg: *byte = arg.str_ptr;
                
                loop [j: int = 0](str_arg[j] != '\0') : (++j) {
                    buffer[buf_index] = str_arg[j];
                    buf_index = buf_index + 1;
                }
                arg_index = arg_index + 1;
                i = i + 1; // Skip the 's'
                continue;
            }
          }
        }
      }

      buffer[buf_index] = s[i];
      buf_index = buf_index + 1;
      i = i + 1;
    }
    buffer[buf_index] = '\0';
    
    let written: int = sys::write_str(sys::STDOUT, buffer);
    return written;
}

/// Prints a formatted error message with integer arguments to stderr
///
/// This function is similar to print_int but writes to stderr instead of stdout.
/// It supports only the %d format specifier for integers and is intended for
/// error reporting.
///
/// # Parameters
/// * `s` - Format string containing text and %d placeholders
/// * `args` - Array of up to 256 integers to substitute into the format string
///
/// # Returns
/// The number of bytes written to stderr, or an error code if writing fails
///
/// # Memory
/// Allocates a 256-byte temporary buffer which is automatically freed via defer
pub const print_err -> fn (s: *byte, args: [int; 256]) int {
  // Simple implementation: only supports %d for integers
  let buffer: *byte = cast<*byte>(alloc(256 * sizeof<byte>));
  let buf_index: int = 0; let arg_index: int = 0;
  defer { free(buffer); }
  
  loop [i: int = 0](s[i] != '\0') : (++i) {
      if (s[i] == '%' && s[i + 1] == 'd' && arg_index < 256) {
          let num_str: *byte = string::from_int(args[arg_index]);
          defer { free(num_str); }

          loop [j: int = 0](num_str[j] != '\0') : (++j) {
              buffer[buf_index] = num_str[j];
              buf_index = buf_index + 1;
          }
          arg_index = arg_index + 1;
          i = i + 1; // Skip 'd'
      } else {
          buffer[buf_index] = s[i];
          buf_index = buf_index + 1;
      }
  }
  buffer[buf_index] = '\0'; // Null-terminate

  let written: int = sys::write_str(sys::STDERR, buffer);
  return written;
}

/// Reads the entire contents of a file into a dynamically allocated buffer
///
/// This function opens a file, reads its complete contents into memory using a
/// dynamic buffer that grows as needed, and returns a pointer to the null-terminated
/// string. The buffer starts at INITIAL_BUFFER_SIZE (4KB) and doubles in size when
/// full until the entire file is read. After reading, the buffer is shrunk to the
/// exact size needed to minimize memory usage.
///
/// # Parameters
/// * `path` - Null-terminated string containing the file path to read
///
/// # Returns
/// A pointer to a newly allocated null-terminated string containing the file contents,
/// or a null pointer (0) if an error occurs. The caller is responsible for freeing
/// this memory.
///
/// # Memory
/// The returned buffer is heap-allocated and ownership is transferred to the caller.
/// The caller MUST free the returned pointer when done. Returns null on allocation
/// failures or read errors.
///
/// # Errors
/// Returns null pointer and prints error message to stderr if:
/// * File cannot be opened
/// * Memory allocation fails
/// * Read operation fails

#returns_ownership
pub const read_file -> fn (path: *byte) *byte {
  let fd: int = sys::open(path, sys::O_RDONLY, 0);
  if (sys::is_error(fd)) {
    sys::eprint("Error: File does not exist, can not read from file\n");
    return cast<*byte>(0);
  }

  // Start with initial buffer
  let buffer_size: int = INITIAL_BUFFER_SIZE;
  let buffer: *byte = cast<*byte>(alloc(buffer_size * sizeof<byte>));
  if (buffer == cast<*byte>(0)) {
    sys::eprint("Error: Failed to allocate initial buffer\n");
    sys::close(fd);
    return cast<*byte>(0);
  }

  let total_read: int = 0;
  let bytes_read: int = 0;

  loop {
    // Read into buffer at current position
    let read_size: int = buffer_size - total_read - 1; // Leave room for null terminator
    bytes_read = sys::read(fd, cast<*void>(cast<int>(buffer) + total_read), read_size);

    if (sys::is_error(bytes_read)) {
      sys::eprint("Error: Failed to read from file\n");
      sys::close(fd);
      free(buffer);
      return cast<*byte>(0);
    }

    // If we read 0 bytes, we've reached EOF
    if (bytes_read == 0) {
      break;
    }

    total_read = total_read + bytes_read;

    // If buffer is full (minus null terminator space), grow it
    if (total_read >= buffer_size - 1) {
      let new_size: int = buffer_size * BUFFER_GROWTH_FACTOR;
      let new_buffer: *byte = cast<*byte>(mem::realloc(cast<*void>(buffer), new_size * sizeof<byte>));
      
      if (new_buffer == cast<*byte>(0)) {
        sys::eprint("Error: Failed to grow buffer\n");
        sys::close(fd);
        free(buffer);
        return cast<*byte>(0);
      }

      buffer = new_buffer;
      buffer_size = new_size;
    }
  }

  // Null terminate the string
  buffer[total_read] = cast<byte>(0);

  // shrink buffer to exact size to save memory
  if (total_read < buffer_size - 1) {
    let final_buffer: *byte = cast<*byte>(alloc((total_read + 1) * sizeof<byte>));
    if (final_buffer != cast<*byte>(0)) {
      mem::memcpy(cast<*void>(final_buffer), cast<*void>(buffer), total_read + 1);
      free(buffer);
      buffer = final_buffer;
    }
  }

  sys::close(fd);
  return buffer;
}

pub const write_buffer_to_file -> fn (path: *byte, buffer: *byte) int {
    // check file exists and open file
    let fd: int = sys::open(path, sys::O_RDWR, 0);
    if (sys::is_error(fd)) {
       sys::eprint("Error: File does not exist, can not to file.\n");
       return -1;
    }
    // check buffer > 0
    let bytes_to_write: int = string::strlen(buffer);
    if (bytes_to_write <= 0) {
       sys::eprint("Error: buffer size <= 0.\n");
       sys::close(fd);
       return -1;
    }
    // dump in one syscall
    let written: int = sys::write(fd, cast<*void>(buffer), bytes_to_write);
    sys::close(fd);

    // return the bytes written to the file
    return written;
}
