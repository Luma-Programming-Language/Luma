@module "main"

@use "std_io" as io

const strlen -> fn (s: *byte) int {
  let length: int = 0;
  loop (s[length] != cast<byte>(0)) : (++length) {}
  return length;
}

const strcmp -> fn (s1: *byte, s2: *byte) int {
  let ls1: int = strlen(s1);
  let ls2: int = strlen(s2);

  if (ls1 != ls2) { return -1; }

  loop[i: int = 0](i < ls1) : (++i) {
    if (s1[i] != s2[i]) { return 1; }
  }

  return 0;
}

const Args -> struct {
  data: **byte, 
  count: int,
  
  len      -> fn () int { return self.count;      },
  is_empty -> fn () int { return -cast<int>(self.count == 0); },
  get      -> fn (index: int) *byte {
    if (index < 0 || index >= self.count) 
      return "";
    let data: **byte = self.data; 
    return data[index];
  },

  contains -> fn (val: *byte) int {
    let data: **byte = self.data;
    loop [i: int = 0](i < self.count) : (++i) {
      if (strcmp(data[i], val) == 0) return 1;
    }
    return 0;
  },


  tail -> fn () Args {
    if (self.count <= 1) return Args { data: self.data, count: 0 };
   
    return Args {
      data: cast<**byte>(cast<int>(self.data) + sizeof<*byte>),
      count: self.count - 1
    };
  }
};

const args_from_main -> fn (argc: int, argv: **byte) Args {
  return Args { data: argv, count: argc };
}

pub const main -> fn (argc: int, argv: **byte) int {
  let args: Args = args_from_main(argc, argv);
  args = args.tail();

  loop [i: int = 0](i < args.len()) : (++i) {
    if (args.is_empty() == 0) 
      io::print("%s\n", [io::str_arg(args.get(i))]);
  }

  return 0;
}
