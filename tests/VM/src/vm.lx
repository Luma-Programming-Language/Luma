@module "vm"

@use "io" as io
@use "sys" as sys
@use "common" as common
@use "debug" as debug

const STACK_SIZE: int = 256;
const PROGRAM_SIZE: int = 1024;

#returns_ownership
pub const create_vm -> fn () VM {
  return VM { 
    sp: -1,
    pc:  0,
    stack: cast<*int>(alloc(sizeof<int> * STACK_SIZE)),
    program: cast<*byte>(alloc(sizeof<byte> * PROGRAM_SIZE))
  };
}

#takes_ownership
pub const free_vm -> fn (vm: *VM) void {
  free(vm.stack);
  free(vm.program);

  vm.sp = -1;
  vm.pc = 0;
}

// Helper: Check if stack has enough values for an operation
const check_stack_has_values -> fn (v: *VM, count: int) void {
  if (v.sp < count - 1) {
    io::print_err("Stack Underflow! Need %d value(s), but stack has %d\n", 
      [count, v.sp + 1]);
    sys::exit(1);
  }
}

pub const push -> fn (v: *VM, value: int) void {
  if (v.sp >= STACK_SIZE - 1) {
    io::print_err("Stack Overflow!\n", [0]);
    sys::exit(1);
  }

  v.sp = v.sp + 1;
  v.stack[v.sp] = value;
  
  debug::trace_push(value);
}

pub const pop -> fn (v: *VM) int {
  check_stack_has_values(v, 1);

  let result: int = v.stack[v.sp];
  v.sp = v.sp - 1;
  
  debug::trace_pop(result);
  
  return result; 
}

pub const write_int -> fn (prog: *byte, pc: *int, val: int) void {
  loop [i: int = 0](i < 8) : (++i) {
    prog[*pc] = cast<byte>((val >> (i * 8)) & 255);
    *pc = *pc + 1;
  }
}

const preform_binary -> fn (v: *VM, op: byte) void {
  check_stack_has_values(v, 2);
  
  let b: int = pop(v);
  let a: int = pop(v);
  let result: int = 0;

  switch (op) {
    '+' -> result = b + a;
    '-' -> result = b - a;
    '*' -> result = b * a;
    '/' -> result = b / a;
  }
  
  push(v, result);
}

const preform_unary -> fn (v: *VM, op: byte) void {
  check_stack_has_values(v, 1);
  
  let a: int = pop(v);
  let result: int = 0;

  switch (op) {
    '-' -> result = -a;
  }
  
  push(v, result);
}

pub const vm_execute -> fn (v: *VM) void {
  debug::trace_header();
  
  loop {
    let op: byte = v.program[v.pc];
    
    debug::trace_instruction(v.pc, cast<int>(op));
    
    v.pc = v.pc + 1;

    switch(cast<int>(op)) {
      common::Opcode::OP_PUSH -> {
        let val: int = 
          (cast<int>(v.program[v.pc + 0]) << 0)  |
          (cast<int>(v.program[v.pc + 1]) << 8)  |
          (cast<int>(v.program[v.pc + 2]) << 16) |
          (cast<int>(v.program[v.pc + 3]) << 24) |
          (cast<int>(v.program[v.pc + 4]) << 32) |
          (cast<int>(v.program[v.pc + 5]) << 40) |
          (cast<int>(v.program[v.pc + 6]) << 48) |
          (cast<int>(v.program[v.pc + 7]) << 56);
        v.pc = v.pc + 8;
        push(v, val);
      }
      common::Opcode::OP_POP  -> { pop(v); }
      common::Opcode::OP_HALT -> {
        debug::trace_halt();
        return;
      }
      common::Opcode::OP_PRINT -> {
        check_stack_has_values(v, 1);
        io::print("%d\n", [io::int_arg(v.stack[v.sp])]);
      }

      // Binary Instructions
      common::Opcode::OP_ADD -> preform_binary(v, '+');
      common::Opcode::OP_SUB -> preform_binary(v, '-');
      common::Opcode::OP_MUL -> preform_binary(v, '*');
      common::Opcode::OP_DIV -> preform_binary(v, '/');

      // Unary Instructions
      common::Opcode::OP_NEG -> preform_unary(v, '-');

      _ -> {
        io::print_err("Unknown Opcode!!\n", [0]);
        return;
      }
    }
    
    debug::print_stack(v);
    debug::trace_separator();
  }
}
