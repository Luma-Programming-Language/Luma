@module "main"  

@use "vm" as vm
@use "common" as common

pub const main -> fn () int {
    let v: VM = vm::create_vm();
    defer { vm::free_vm(&v); }

    let pc: int = 0;
    let loop_start: int = 0;
    
    // Push initial counter (0)
    v.program[pc++] = cast<byte>(common::Opcode::OP_PUSH);
    vm::write_int(v.program, &pc, 0);
    
    loop_start = pc;  // Mark loop start
    
    // Increment counter
    v.program[pc++] = cast<byte>(common::Opcode::OP_PUSH);
    vm::write_int(v.program, &pc, 1);
    v.program[pc++] = cast<byte>(common::Opcode::OP_ADD);
    
    // Duplicate the counter for printing (so we don't lose it)
    v.program[pc++] = cast<byte>(common::Opcode::OP_DUP);
    
    // Print current value
    v.program[pc++] = cast<byte>(common::Opcode::OP_PRINT);
    
    // Duplicate again for comparison
    v.program[pc++] = cast<byte>(common::Opcode::OP_DUP);
    
    // Check if less than 5
    v.program[pc++] = cast<byte>(common::Opcode::OP_PUSH);
    vm::write_int(v.program, &pc, 5);
    v.program[pc++] = cast<byte>(common::Opcode::OP_LT);
    
    // Jump back if true (counter < 5)
    v.program[pc++] = cast<byte>(common::Opcode::OP_JNZ);
    vm::write_int(v.program, &pc, loop_start);
    
    // Clean up: pop the final counter value
    v.program[pc++] = cast<byte>(common::Opcode::OP_POP);
    
    v.program[pc++] = cast<byte>(common::Opcode::OP_HALT);
    
    vm::vm_execute(&v);
    return 0;
}
