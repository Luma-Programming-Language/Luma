@module "lexer"

@use "lexer_tokens" as sym

const is_alpha -> fn (c: byte) bool {
  return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c == '_');
}
const is_digit -> fn (c: byte) bool { return (c >= '0' && c <= '9'); }
const is_alnum -> fn (c: byte) bool { return is_alpha(c) || is_digit(c); }

const skip_line_comment -> fn (lx: *Lexer) void {
  loop (lx.is_end() == 0 && lx.peek(0) != '\n') {
    lx.advance();
  }
}

const skip_block_comment -> fn (lx: *Lexer) void {
  lx.advance(); // skip /
  lx.advance(); // skip *
  loop (lx.is_end() == 0) {
    if (lx.peek(0) == '*' && lx.peek(1) == '/') {
      lx.advance(); // skip *
      lx.advance(); // skip /
      return;
    }
    lx.advance();
  }
}

const skip_whitespace -> fn (lx: *Lexer) int {
  let count: int = 0;
  loop (lx.is_end() == 0) {
    let c: byte = lx.peek(0);

    if (c == ' ' || c == '\t') {
      lx.advance();
      count = count + 1;
    } elif (c == '\n' || c == '\r') {
      lx.advance();
      count = 0;
    } elif (c == '/' && lx.peek(1) == '/') {
      if (lx.peek(2) == '/' || lx.peek(2) == '!') {
        return count;
      }
      skip_line_comment(lx);
      count = 0;
    } elif (c == '/' && lx.peek(1) == '*') {
      skip_block_comment(lx);
      count = 0;
    } else {
      return count;
    }
  }
  return count;
}

const make_token -> fn (val: *byte, kind: int, len: int, line: int, whitespace_len: int) Token {
  return Token { val: val, kind: kind, len: len, line: line, whitespace_len: whitespace_len };
}

pub const next_token -> fn (lx: *Lexer) Token {
  loop (1) {
    let ws: int = skip_whitespace(lx);

    if (lx.is_end() == 1)
      return make_token(lx.current, sym::LumaTokenType::TOK_EOF, 0, lx.line, ws);

    let start: *byte = lx.current;
    let c: byte = lx.peek(0);
    let line: int = lx.line;

    // Preprocessor directives @module @use
    if (c == '@') {
      lx.advance();
      let len: int = 1;
      loop (lx.is_end() == 0 && is_alnum(lx.peek(0))) {
        lx.advance();
        len = len + 1;
      }
      let word: *byte = sym::create_word(start, len);
      let kind: int = sym::lookup_keyword(word);
      free(word);
      if (kind != -1) { return make_token(start, kind, len, line, ws); }
      return make_token(start, sym::LumaTokenType::TOK_ERROR, len, line, ws);
    }

    // Function attributes #returns_ownership #takes_ownership
    if (c == '#') {
      lx.advance();
      let len: int = 1;
      loop (lx.is_end() == 0 && (is_alnum(lx.peek(0)) || lx.peek(0) == '_')) {
        lx.advance();
        len = len + 1;
      }
      let word: *byte = sym::create_word(start, len);
      let kind: int = sym::lookup_keyword(word);
      free(word);
      if (kind != -1) { return make_token(start, kind, len, line, ws); }
      return make_token(start, sym::LumaTokenType::TOK_ERROR, len, line, ws);
    }

    // String literal
    if (c == '"') {
      lx.advance();
      let len: int = 0;
      loop (lx.is_end() == 0 && lx.peek(0) != '"') {
        if (lx.peek(0) == '\n') {
          return make_token(start, sym::LumaTokenType::TOK_ERROR, len, line, ws);
        }
        lx.advance();
        len = len + 1;
      }
      if (lx.is_end() == 1) {
        return make_token(start, sym::LumaTokenType::TOK_ERROR, len, line, ws);
      }
      lx.advance(); // closing "
      let inner_start: *byte = cast<*byte>(cast<int>(start) + 1);
      return make_token(inner_start, sym::LumaTokenType::TOK_STRING, len, line, ws);
    }

    // Char literal
    if (c == '\'') {
      lx.advance();
      if (lx.is_end() == 1 || lx.peek(0) == '\'') {
        return make_token(start, sym::LumaTokenType::TOK_ERROR, 1, line, ws);
      }
      if (lx.peek(0) == '\\') {
        lx.advance();
        lx.advance();
      } else {
        lx.advance();
      }
      if (lx.peek(0) != '\'') {
        return make_token(start, sym::LumaTokenType::TOK_ERROR, 2, line, ws);
      }
      lx.advance(); // closing '
      return make_token(start, sym::LumaTokenType::TOK_CHAR_LITERAL, 3, line, ws);
    }

    // Number
    if (is_digit(c)) {
      let len: int = 0;
      loop (lx.is_end() == 0 && is_digit(lx.peek(0))) {
        lx.advance();
        len = len + 1;
      }
      if (lx.is_end() == 0 && lx.peek(0) == '.' && is_digit(lx.peek(1))) {
        lx.advance();
        len = len + 1;
        loop (lx.is_end() == 0 && is_digit(lx.peek(0))) {
          lx.advance();
          len = len + 1;
        }
        return make_token(start, sym::LumaTokenType::TOK_NUM_FLOAT, len, line, ws);
      }
      return make_token(start, sym::LumaTokenType::TOK_NUMBER, len, line, ws);
    }

    // Identifier or keyword
    if (is_alpha(c)) {
      let len: int = 0;
      loop (lx.is_end() == 0 && is_alnum(lx.peek(0))) {
        lx.advance();
        len = len + 1;
      }
      let word: *byte = sym::create_word(start, len);
      defer { free(word); }
      let kind: int = sym::lookup_keyword(word);
      if (kind != -1) return make_token(start, kind, len, line, ws);
      return make_token(start, sym::LumaTokenType::TOK_IDENTIFIER, len, line, ws);
    }

    // Double symbol
    let kind: int = sym::lookup_double(c, lx.peek(1));
    if (kind != -1) {
      lx.advance();
      lx.advance();
      return make_token(start, kind, 2, line, ws);
    }

    // Single symbol
    kind = sym::lookup_single(c);
    if (kind != -1) {
      lx.advance();
      return make_token(start, kind, 1, line, ws);
    }

    // Unrecognized
    lx.advance();
  }

  return make_token(lx.current, sym::LumaTokenType::TOK_EOF, 0, lx.line, 0);
}
