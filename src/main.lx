@module "main"

@use "std_string" as STRING
@use "std_vector" as VEC
@use "std_memory" as MEM
@use "std_args" as ARGS
@use "std_io" as IO

@use "lexer_tokens" as TOK
@use "constants" as CONST
@use "commands" as COMD
@use "lexer" as LEXER
@use "parser" as PARS
@use "error" as ERR

@use "ast_stmt" as STMT
@use "ast" as AST

pub const main -> fn (argc: int, argv: **byte) int {
  let args: Args = ARGS::init_args(argc, argv);
  args = args.tail();
  
  if (args.is_empty() == 1 || COMD::match_command(args.get(0), ["-h", "--help"], 2) == 1) {
    COMD::print_commands();
    return 0;
  } elif (COMD::match_command(args.get(0), ["-v", "--version"], 2) == 1) {
    output("Luma Compiler ", CONST::Luma_Compiler_version, "\n");
    return 0;
  } elif (COMD::match_command(args.get(0), ["-l", "--license"], 2) == 1) {
    COMD::print_license(); 
    return 0;
  }
  
  let link_files: Vector = VEC::create_vector(sizeof<*byte>);
  defer { VEC::free_vector(&link_files); }

  let build_config: LumaBuildConfig = CONST::init_build_config(args.get(0), &link_files);
  if (COMD::parse_args(&args, &build_config, &link_files) != 0) { return 1; }

  // Lexer Stage ----------------------------------------------------------
  let tokens: Vector = VEC::create_vector(sizeof<Token>);
  let src: *byte = IO::read_file(build_config.filepath);
  let lexer: Lexer = TOK::create_lexer(src);
  defer { VEC::free_vector(&tokens); free(src); }
  
  loop (LEXER::is_end(&lexer) == 0) {
    let tok: Token = LEXER::next_token(&lexer);
    tokens.push_back(cast<*void>(&tok));
  }
  tokens.remove_at(tokens.size - 1); // Remove the EOF token
  
  // Parser Stage ----------------------------------------------------------
  let tks: *Token = cast<*Token>(tokens.data);
  let p: *Parser = PARS::create_parser(tks, tokens.size, build_config.filepath);
  defer { PARS::free_parser(p); }
  
  // Try consuming an @module token â€” first token should be this
  p.consume(TOK::LumaTokenType::TOK_MODULE, "Expected @module at start of file");

  if (ERR::error_has_errors() == 1) {
    ERR::error_report();
    ERR::error_clear();
    return 1;
  }

  output("consume worked, pos is now: ", p.pos, "\n");

  return 0;
}
