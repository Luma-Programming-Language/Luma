@module "parser"

@use "std_vector" as VEC

@use "lexer_tokens" as TOK
@use "error" as ERR
@use "ast" as AST

@use "parser_stmt" as PSTMT

pub const BindingPower -> enum {
  BP_NONE,        /**< No binding power */
  BP_LOWEST,      /**< Lowest binding power */
  BP_ASSIGN,      /**< Assignment operators (=, +=, etc.) */
  BP_TERNARY,     /**< Ternary conditional operator (? :) */
  BP_LOGICAL_OR,  /**< Logical OR operator (||) */
  BP_LOGICAL_AND, /**< Logical AND operator (&&) */
  BP_BITWISE_OR,  /**< Bitwise OR operator (|) */
  BP_BITWISE_XOR, /**< Bitwise XOR operator (^) */
  BP_BITWISE_AND, /**< Bitwise AND operator (&) */
  BP_EQUALITY,    /**< Equality operators (==, !=) */
  BP_RELATIONAL,  /**< Relational operators (<, >, <=, >=) */
  BP_RANGE,       /**< Range operations (..) */
  BP_SHIFT,       /**< Shift operators (<<, >>) */
  BP_SUM,         /**< Addition and subtraction (+, -) */
  BP_PRODUCT,     /**< Multiplication, division, modulo (*, /, %) */
  BP_EXPONENT,    /**< Exponentiation operator (**) */
  BP_UNARY,       /**< Unary operators (!, ~, +, -, prefix ++/--) */
  BP_POSTFIX,     /**< Postfix operators (++/-- postfix) */
  BP_CALL,        /**< Function call or indexing */
  BP_PRIMARY      /**< Primary expressions (literals, variables) */
};

const PRIMARY_LITERAL_TYPE_MAP: int =  7; 
const TOKEN_TO_BINOP_MAP:       int = 19;
const TOKEN_TO_UNOP_MAP:        int =  6;    

const PRIMARY_LITERAL -> struct { tok: int, literal: int };
const TOKEN_TO_BINOP  -> struct { tok: int, binop: int   };
const TOKEN_TO_UNOP   -> struct { tok: int, unop: int    };

pub const PRIMARY_TILERAL_MAP: [PRIMARY_LITERAL; 7] = [
  PRIMARY_LITERAL { tok: TOK::LumaTokenType::TOK_NUMBER,       literal: AST::LiteralType::LITERAL_INT    },      
  PRIMARY_LITERAL { tok: TOK::LumaTokenType::TOK_NUM_FLOAT,    literal: AST::LiteralType::LITERAL_FLOAT  },
  PRIMARY_LITERAL { tok: TOK::LumaTokenType::TOK_STRING,       literal: AST::LiteralType::LITERAL_STRING },   
  PRIMARY_LITERAL { tok: TOK::LumaTokenType::TOK_CHAR_LITERAL, literal: AST::LiteralType::LITERAL_CHAR   },
  PRIMARY_LITERAL { tok: TOK::LumaTokenType::TOK_TRUE,         literal: AST::LiteralType::LITERAL_BOOL   },     
  PRIMARY_LITERAL { tok: TOK::LumaTokenType::TOK_FALSE,        literal: AST::LiteralType::LITERAL_BOOL   },
  PRIMARY_LITERAL { tok: TOK::LumaTokenType::TOK_IDENTIFIER,   literal: AST::LiteralType::LITERAL_IDENT  },
];

pub const BINOP_MAP: [TOKEN_TO_BINOP; 19] = [
  TOKEN_TO_BINOP { tok: TOK::LumaTokenType::TOK_PLUS,        binop: AST::BinaryOp::BINOP_ADD     },
  TOKEN_TO_BINOP { tok: TOK::LumaTokenType::TOK_MINUS,       binop: AST::BinaryOp::BINOP_SUB     },
  TOKEN_TO_BINOP { tok: TOK::LumaTokenType::TOK_STAR,        binop: AST::BinaryOp::BINOP_MUL     },
  TOKEN_TO_BINOP { tok: TOK::LumaTokenType::TOK_SLASH,       binop: AST::BinaryOp::BINOP_DIV     },
  TOKEN_TO_BINOP { tok: TOK::LumaTokenType::TOK_EQEQ,        binop: AST::BinaryOp::BINOP_EQ      },
  TOKEN_TO_BINOP { tok: TOK::LumaTokenType::TOK_NEQ,         binop: AST::BinaryOp::BINOP_NE      },
  TOKEN_TO_BINOP { tok: TOK::LumaTokenType::TOK_LT,          binop: AST::BinaryOp::BINOP_LT      },
  TOKEN_TO_BINOP { tok: TOK::LumaTokenType::TOK_LE,          binop: AST::BinaryOp::BINOP_LE      },
  TOKEN_TO_BINOP { tok: TOK::LumaTokenType::TOK_GT,          binop: AST::BinaryOp::BINOP_GT      },
  TOKEN_TO_BINOP { tok: TOK::LumaTokenType::TOK_GE,          binop: AST::BinaryOp::BINOP_GE      },
  TOKEN_TO_BINOP { tok: TOK::LumaTokenType::TOK_AND,         binop: AST::BinaryOp::BINOP_AND     },
  TOKEN_TO_BINOP { tok: TOK::LumaTokenType::TOK_OR,          binop: AST::BinaryOp::BINOP_OR      },
  TOKEN_TO_BINOP { tok: TOK::LumaTokenType::TOK_AMP,         binop: AST::BinaryOp::BINOP_BIT_AND },
  TOKEN_TO_BINOP { tok: TOK::LumaTokenType::TOK_PIPE,        binop: AST::BinaryOp::BINOP_BIT_OR  },
  TOKEN_TO_BINOP { tok: TOK::LumaTokenType::TOK_CARET,       binop: AST::BinaryOp::BINOP_BIT_XOR },
  TOKEN_TO_BINOP { tok: TOK::LumaTokenType::TOK_RANGE,       binop: AST::BinaryOp::BINOP_RANGE   },
  TOKEN_TO_BINOP { tok: TOK::LumaTokenType::TOK_MODL,        binop: AST::BinaryOp::BINOP_MOD     },
  TOKEN_TO_BINOP { tok: TOK::LumaTokenType::TOK_SHIFT_LEFT,  binop: AST::BinaryOp::BINOP_SHL     },
  TOKEN_TO_BINOP { tok: TOK::LumaTokenType::TOK_SHIFT_RIGHT, binop: AST::BinaryOp::BINOP_SHR     },
];

pub const UNOP_MAP: [TOKEN_TO_UNOP; 6] = [
  TOKEN_TO_UNOP { tok: TOK::LumaTokenType::TOK_BANG,       unop: AST::UnaryType::UNOP_NOT      },
  TOKEN_TO_UNOP { tok: TOK::LumaTokenType::TOK_TILDE,      unop: AST::UnaryType::UNOP_BIT_NOT  },
  TOKEN_TO_UNOP { tok: TOK::LumaTokenType::TOK_PLUS,       unop: AST::UnaryType::UNOP_POS      },
  TOKEN_TO_UNOP { tok: TOK::LumaTokenType::TOK_MINUS,      unop: AST::UnaryType::UNOP_NEG      },
  TOKEN_TO_UNOP { tok: TOK::LumaTokenType::TOK_PLUSPLUS,   unop: AST::UnaryType::UNOP_POST_INC },
  TOKEN_TO_UNOP { tok: TOK::LumaTokenType::TOK_MINUSMINUS, unop: AST::UnaryType::UNOP_POST_DEC },
];

const EOF_TOK: Token = { val: "", kind: TOK::LumaTokenType::TOK_EOF, len: 0, line: 0, whitespace_len: 0 }; 

pub const get_bp -> fn (kind: int) int {
  switch (kind) {
    TOK::LumaTokenType::TOK_EQUAL    -> return BindingPower::BP_ASSIGN;
    TOK::LumaTokenType::TOK_QUESTION -> return BindingPower::BP_TERNARY;

    TOK::LumaTokenType::TOK_OR       -> return BindingPower::BP_LOGICAL_OR;
    TOK::LumaTokenType::TOK_AND      -> return BindingPower::BP_LOGICAL_AND;

    TOK::LumaTokenType::TOK_PIPE     -> return BindingPower::BP_BITWISE_OR;
    TOK::LumaTokenType::TOK_CARET    -> return BindingPower::BP_BITWISE_XOR;
    TOK::LumaTokenType::TOK_AMP      -> return BindingPower::BP_BITWISE_AND;

    TOK::LumaTokenType::TOK_RANGE -> BindingPower::BP_RANGE;

    TOK::LumaTokenType::TOK_EQEQ, TOK::LumaTokenType::TOK_NEQ 
      -> return BindingPower::BP_EQUALITY;

    TOK::LumaTokenType::TOK_LT, TOK::LumaTokenType::TOK_LE,
    TOK::LumaTokenType::TOK_GT, TOK::LumaTokenType::TOK_GE 
      -> return BindingPower::BP_RELATIONAL;

    TOK::LumaTokenType::TOK_SHIFT_LEFT, TOK::LumaTokenType::TOK_SHIFT_RIGHT 
      -> return BindingPower::BP_SHIFT;

    TOK::LumaTokenType::TOK_PLUS, TOK::LumaTokenType::TOK_MINUS 
      -> return BindingPower::BP_SUM;

    TOK::LumaTokenType::TOK_STAR, TOK::LumaTokenType::TOK_SLASH,
    TOK::LumaTokenType::TOK_MODL 
      -> return BindingPower::BP_PRODUCT;

    TOK::LumaTokenType::TOK_PLUSPLUS, TOK::LumaTokenType::TOK_MINUSMINUS
      -> return BindingPower::BP_POSTFIX;

    TOK::LumaTokenType::TOK_LPAREN, TOK::LumaTokenType::TOK_LBRACKET,
    TOK::LumaTokenType::TOK_LBRACE, TOK::LumaTokenType::TOK_DOT, 
    TOK::LumaTokenType::TOK_RESOLVE 
      -> return BindingPower::BP_CALL;

    _ -> return BindingPower::BP_NONE;
  }
}

pub const Parser -> struct {
  file_path:   *byte,
  tks:         *Token,
  tok_count:   int,
  pos:         int,
  had_error:   int,

  has_tokens -> fn () bool { return (self.pos < self.tok_count); },
  peek       -> fn (offset: int) Token {
    let idx: int = self.pos + offset;
    if (idx < self.tok_count)  
      return self.tks[idx]; 
    return EOF_TOK; 
  },
  current    -> fn () Token {
    if (self.pos < self.tok_count)  
      return self.tks[self.pos]; 
    return EOF_TOK; 
  },
  advance    -> fn () Token {
    if (self.has_tokens()) { 
      self.pos = self.pos + 1;
      return self.tks[self.pos];
    }
    return EOF_TOK;
  },
  consume    -> fn (kind: int, err_msg: *byte) Token {
    let line: int = self.current().line;
    let col:  int = self.current().whitespace_len;

    if (self.current().kind == kind) 
      return self.advance();

    // Create a Parser Error
    let info: ErrorInformation = ErrorInformation {
      error_type:   "Parser Error",
      file_path:    self.file_path,
      message:      err_msg,
      line:         line,
      col:          col,
      line_text:    ERR::generate_line(self.tks, self.tok_count, line),
      token_length: 1,
      label:        cast<*byte>(0),
      note:         cast<*byte>(0),
      help:         cast<*byte>(0),
    };
    ERR::error_add(info);
    self.had_error = 1;

    return EOF_TOK;
  }
};

#returns_ownership
pub const create_parser -> fn (tks: *Token, tok_count: int, file_path: *byte) *Parser {
  let p: *Parser = cast<*Parser>(alloc(sizeof<Parser>));

  p.file_path = file_path;
  p.tok_count = tok_count;
  p.had_error = 0;
  p.tks = tks;
  p.pos = 0;

  return p;
}

#takes_ownership
pub const free_parser -> fn (p: *Parser) void {
  free(p);
}
